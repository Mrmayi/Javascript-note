# 内存

JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。浏览器采用了两种对于变量的垃圾回收机制。

## 标记清除

JavaScript中最常用的垃圾收集方式是标记清除（mark-and-sweep）。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

到2008年为止，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。

摘录来自: 泽卡斯. “JavaScript高级程序设计（第3版）”。 iBooks.

## 引用计数

引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。”

摘录来自: 泽卡斯. “JavaScript高级程序设计（第3版）”。 iBooks.

但是由于循环引用而造成的引用次数永不为零带来的问题，因此引用计数的方式会放弃了。

## 管理内存

我们可以手动触发垃圾收集（不建议使用）：

1. 在IE中，调用window.CollectGarbage()方法会立即执行垃圾收集。
2. 在0pera7及更高版本中，调用window.opera.collect()也会启动垃圾收集例程。

在平时的开发中，对于不在使用的变量，可以将它的值设置为null，用于解除变量的引用。这样变量所占内存在下一次垃圾回收中被删除。

```javascript
let fnObj = () => {
    let data = new Object();
    data.name = 'xiaoli';
    return data;
};

let windowData = fnObj();

alert(windowData.name);

// 这样 fnObj 中 data 所占的内存就会被清除
windowData = null;
```